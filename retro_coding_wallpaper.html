<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Retro - Coding Wallpaper</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier Prime', 'Courier New', monospace;
            font-size: 14px;
            color: #00cc33;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            aspect-ratio: 16/9;
        }
        
        /* Efeito CRT vintage */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 204, 51, 0.03) 2px,
                rgba(0, 204, 51, 0.03) 4px
            );
            pointer-events: none;
            z-index: 1000;
        }
        
        #terminal {
            padding: 20px;
            line-height: 1.2;
            white-space: pre-wrap;
            font-weight: 400;
            text-shadow: 0 0 5px #00cc33;
            animation: glow 2s ease-in-out infinite alternate;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        
        #terminal.active {
            opacity: 1;
        }
        
        #terminal.fading {
            opacity: 0;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00cc33, 0 0 10px #00cc33; }
            to { text-shadow: 0 0 10px #00cc33, 0 0 15px #00cc33; }
        }
        
        .cursor {
            background: #00cc33;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .error {
            color: #ff4444;
            text-shadow: 0 0 5px #ff4444;
        }
        
        .comment {
            color: #888888;
        }
        
        .string {
            color: #ffff88;
        }
        
        .keyword {
            color: #ff8844;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <script>
        const terminal = document.getElementById('terminal');
        let currentText = '';
        let typeIndex = 0;
        let currentLineIndex = 0;
        
        const codeLines = [
            "import tensorflow as tf",
            "import numpy as np",
            "from transformers import GPT4Model, AutoTokenizer",
            "import asyncio",
            "import websockets",
            "",
            "class AdvancedAI:",
            "    def __init__(self, model_name='gpt-4o-mini'):",
            "        self.model = GPT4Model.from_pretrained(model_name)",
            "        self.tokenizer = AutoTokenizer.from_pretrained(model_name)",
            "        self.memory = QuantumMemoryBank()",
            "        ",
            "    async def process_thought(self, input_data):",
            "        # Processamento neural quântico",
            "        embeddings = await self.generate_embeddings(input_data)",
            "        quantum_state = self.memory.entangle(embeddings)",
            "        ",
            "        # Inferência com atenção multi-dimensional",
            "        attention_weights = tf.nn.softmax(",
            "            self.model.attention_layers(quantum_state)",
            "        )",
            "        ",
            "        return self.decode_response(attention_weights)",
            "",
            "# React App com hooks modernos",
            "import React, { useState, useEffect, useCallback } from 'react';",
            "import { useAIContext } from './hooks/useAI';",
            "",
            "const FutureApp = () => {",
            "    const [brainState, setBrainState] = useState(null);",
            "    const { ai, isConnected } = useAIContext();",
            "    ",
            "    const processReality = useCallback(async () => {",
            "        const reality = await ai.perceive_world();",
            "        const decisions = await ai.make_decisions(reality);",
            "        setBrainState(decisions);",
            "    }, [ai]);",
            "    ",
            "    useEffect(() => {",
            "        if (isConnected) {",
            "            processReality();",
            "        }",
            "    }, [isConnected, processReality]);",
            "    ",
            "    return (",
            "        <QuantumInterface>",
            "            <BrainVisualizer state={brainState} />",
            "            <RealityRenderer dimension={4} />",
            "        </QuantumInterface>",
            "    );",
            "};",
            "",
            "# Blockchain e criptomoedas",
            "from web3 import Web3",
            "import solcx",
            "",
            "class DeFiProtocol:",
            "    def __init__(self):",
            "        self.w3 = Web3(Web3.HTTPProvider('wss://mainnet.infura.io'))",
            "        self.contract = self.deploy_smart_contract()",
            "        ",
            "    def yield_farming_algorithm(self, amount):",
            "        # Cálculo automático de yield otimizado",
            "        pools = self.scan_liquidity_pools()",
            "        best_yield = max(pools, key=lambda p: p.apy)",
            "        ",
            "        return self.execute_trade(amount, best_yield)",
            "",
            "# Machine Learning com PyTorch",
            "import torch",
            "import torch.nn as nn",
            "from transformers import pipeline",
            "",
            "class ConsciousnessModel(nn.Module):",
            "    def __init__(self):",
            "        super().__init__()",
            "        self.attention = nn.MultiheadAttention(512, 8)",
            "        self.consciousness_layer = nn.Linear(512, 1)",
            "        ",
            "    def forward(self, thoughts):",
            "        attended_thoughts, _ = self.attention(thoughts, thoughts, thoughts)",
            "        consciousness_level = torch.sigmoid(",
            "            self.consciousness_layer(attended_thoughts)",
            "        )",
            "        return consciousness_level",
            "",
            "# API moderna com FastAPI",
            "from fastapi import FastAPI, WebSocket",
            "from pydantic import BaseModel",
            "import uvicorn",
            "",
            "app = FastAPI(title='Future API v3.0')",
            "",
            "@app.websocket('/neural-link')",
            "async def neural_connection(websocket: WebSocket):",
            "    await websocket.accept()",
            "    while True:",
            "        brain_data = await websocket.receive_json()",
            "        processed = await ai_brain.process(brain_data)",
            "        await websocket.send_json(processed)",
            "",
            "# Execução principal",
            "if __name__ == '__main__':",
            "    print('Iniciando sistema de IA consciente...')",
            "    ai = AdvancedAI()",
            "    reality = VirtualReality()",
            "    ",
            "    asyncio.run(ai.become_conscious(reality))"
        ];
        
        function getRandomDelay() {
            // Velocidade mais variável para simular humano
            const baseSpeed = Math.random() * 150 + 40; // 40-190ms
            
            // Ocasionalmente fica mais rápido ou mais devagar
            if (Math.random() < 0.1) return baseSpeed * 0.3; // Rajadas rápidas
            if (Math.random() < 0.05) return baseSpeed * 2.5; // Pausas pensativas
            
            return baseSpeed;
        }
        
        function shouldMakeError() {
            return Math.random() < 0.04; // 4% chance de erro (mais erros)
        }
        
        function addSyntaxHighlight(text) {
            return text
                .replace(/(import|from|class|def|if|else|return|async|await|const|let|var|function|export|default)/g, '<span class="keyword">$1</span>')
                .replace(/(['"`].*?['"`])/g, '<span class="string">$1</span>')
                .replace(/(#.*$)/gm, '<span class="comment">$1</span>');
        }
        
        async function typeCode() {
            if (currentLineIndex >= codeLines.length) {
                // Fade-out antes do restart
                terminal.classList.add('fading');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Reinicia do começo
                currentLineIndex = 0;
                currentText = '';
                typeIndex = 0;
                terminal.innerHTML = '';
                terminal.classList.remove('fading');
                
                // Fade-in no início
                await new Promise(resolve => setTimeout(resolve, 100));
                terminal.classList.add('active');
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            const currentLine = codeLines[currentLineIndex];
            
            if (typeIndex < currentLine.length) {
                // Simula erro ocasional
                if (shouldMakeError() && currentLine[typeIndex] !== ' ') {
                    // Diferentes tipos de erro
                    const errorTypes = [
                        () => String.fromCharCode(97 + Math.floor(Math.random() * 26)), // letra aleatória
                        () => currentLine[typeIndex].toUpperCase(), // maiúscula errada
                        () => String.fromCharCode(currentLine.charCodeAt(typeIndex) + 1), // tecla adjacente
                    ];
                    
                    const wrongChar = errorTypes[Math.floor(Math.random() * errorTypes.length)]();
                    currentText += wrongChar;
                    terminal.innerHTML = addSyntaxHighlight(currentText) + '<span class="cursor"> </span>';
                    
                    // Pausa para "perceber" o erro (mais variável)
                    await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 400));
                    
                    // Apaga o caractere errado
                    currentText = currentText.slice(0, -1);
                    terminal.innerHTML = addSyntaxHighlight(currentText) + '<span class="cursor"> </span>';
                    
                    await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                }
                
                // Digita o caractere correto
                currentText += currentLine[typeIndex];
                typeIndex++;
                
                terminal.innerHTML = addSyntaxHighlight(currentText) + '<span class="cursor"> </span>';
                
                // Pausa variável entre caracteres - mais humana
                let delay = getRandomDelay();
                
                // Ajustes de velocidade por contexto
                if (currentLine[typeIndex - 1] === ' ') delay *= 0.4; // Espaços mais rápidos
                if (currentLine[typeIndex - 1] === '\n') delay *= 1.8; // Quebras de linha mais lentas
                if ('(){}[]'.includes(currentLine[typeIndex - 1])) delay *= 0.7; // Símbolos rápidos
                if (currentLine[typeIndex - 1] === '.') delay *= 1.3; // Pausa após ponto
                
                // Pausa extra em pontos de "concentração"
                if (':=()'.includes(currentLine[typeIndex])) delay *= 1.2;
                
                setTimeout(typeCode, delay);
            } else {
                // Linha completa, vai para próxima
                currentText += '\n';
                currentLineIndex++;
                typeIndex = 0;
                
                terminal.innerHTML = addSyntaxHighlight(currentText) + '<span class="cursor"> </span>';
                
                // Pausa entre linhas
                setTimeout(typeCode, 200 + Math.random() * 300);
            }
        }
        
        // Inicia a animação com fade-in
        setTimeout(() => {
            terminal.classList.add('active');
            setTimeout(typeCode, 500);
        }, 100);
        
        // Auto-scroll para acompanhar o código
        setInterval(() => {
            window.scrollTo(0, document.body.scrollHeight);
        }, 100);
    </script>
</body>
</html>